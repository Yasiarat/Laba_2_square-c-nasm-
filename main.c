#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <locale.h>
#define dx (double)(b - a)/n
#define MAX_ITER 1000000

// Функции написанные на асемблере
extern double f1(double x);
extern double f2(double x);
extern double f3(double x);

int iter = 0;
double eps = 0.001;

// для отладки
double f(double x) {
    double y = 5*x*x-3*x - 4;
    return y;
}

// метод хорд
double method_chord(double prev, double now, double e)
{
    double next = 0;
    double tmp;

    while (abs(next - now) > e) {
        tmp = next;
        next = now - f(now) * (prev - now) / (f(prev) - f(now));
        prev = now;
        now = tmp;
        iter++;
    }

    return next;
}

// поиск тосчки разности функций на [a, b]
double root(double (*f)(double x), double (*g)(double x), double a, double b, double eps1) {
    double a0 = f(a) - g(a);
    double b0 = f(b) - g(b);

    // если совпадает с границами
    if (a0 == 0) return a;
    if (b0 == 0) return b;
    // если функции одного знака - корня не существует
    if (a0 * b0 > 0) {
        printf("Корень уравнения f(x) = g(x) на отрезке [%.3lf, %.3lf] не существует или не изолирован.\n", a, b);
        return 0.0/0.0; // NONE
    }

    double r = method_chord(a0, b0, eps1);

    // Если потребовалось слишком большое кол-во итераций, то
	// задан неоптимальный отрезок
    	if (iter >= MAX_ITER) {
		printf("Поиск корня уравнения f(x) - g(x) = 0 на отрезке ");
		printf("[%.2lf, %.2lf] занял слишком много времени.\n", a0, b0);
		iter = 0;
		return 0.0/0.0;
	}

	return r;
}

// метод прямоугоольников подсчёта интегралов
// n - кол-во отрезков разб-я
// a - левая граница, b - правая граница
int integ(double (*f)(double x), double a, double b, double eps1) {
    int i = 1, n = 1;
    double x = 0, y = 0, s = 0;// s - площадь
    double err = eps + 1.0;
    for(x = a, s = 0, i = 1; i <= n; i++) {
        if (err > eps / 2) break;
        y = (*f)(x);
        s += y * dx;
        x += dx;
    }
    return s;
}

// функция площади фигуры
double area(int flag_x) {
    double eps1 = eps/10.0;
    // считаем границы
    double r13 = root(f1, f3, -3.0, -2.0, eps1);
    double r12 = root(f1, f2, 1.0, 2.0, eps1);
    double r23 = root(f2, f3, 0.5, 1.0, eps1);

    if (flag_x)
		printf("Абсциссы точек пересечения кривых:\n\tf1 и f2: %.5lf,\n\tf1 и f3: %.5lf,\n\tf2 и f3: %.5lf\n", r12, r13, r23);
    // Значения интегралв ф-ий на нужных отрезках
	double inf1 = integ(f1, r13, r12, eps1);
	double inf2 = integ(f2, r23, r12, eps1);
	double inf3 = integ(f3, r13, r23, eps1);

	double area = inf1 - (inf2 + inf3); // нужная часть
	return area;
}

int main(int argc, char** argv)
{
    // Для корректного вывода кириллицы в консоль
	setlocale(LC_ALL, ".UTF-8");

    double x0 = 3;
    double x1 = 10;
    double e = 0.03;
    double x = method_chord(x0, x1, e);
    printf("%f", x);

    int i;
     int fl_D = 0, fl_A = 0, fl_S = 0, fl_P = 0; // флаги задания параметров


     if(argc <= 1) {
        start(); // поздороваемся
         return 0;
     }

     if(!strcmp(argv[1], "--help") || !strcmp(argv[1], "-H")){ // если строки ровны
         help(); // выведем возможные ключи и что они делают
         return 0;
     }

    for(int i = 1 ; i < argc; i++) { // пробегаемся по всем аргументам массива

        if(!strcmp(argv[i], "--dim") || !strcmp(argv[i], "-D")){ // ключ задаёт размер входного массива
            i++;

            if(fl_D != 0) { // если дважды ввели один и тот же аргумент
                printf("  Вы ввели два одинаковых ключа! Я буду использовать последний.\n");
             }
            // если нет аргумента или он не валидный
             if ((i == argc) || (atoi(argv[i]) == 0) || (atoi(argv[i]) <= 0)) {//
                printf("  Без аргумента мне не справиться с задачей... \n Ключ '--dim' принимает в качестве аргумента натуральное число.\n");
                return 0;
            }
            fl_D = 1;
            dim = atoi(argv[i]);
        }
    // упорядоченность входного массива
        else if(!strcmp(argv[i], "--arr") || !strcmp(argv[i], "-A")){
            i++;
            if(fl_A != 0) { // если дважды ввели один и тот же аргумент
                printf("  Вы ввели два одинаковых ключа! Я буду использовать последний.\n");
             }
             // если нет аргумента или он не валидный
            if((i == argc) || (atoi(argv[i]) > 4) || (atoi(argv[i]) < 1)){
                printf("  Без аргументов мне не справиться с задачей... \n Ключ '--arr' принимает в качестве аргумента числа от 1 до 4.\n Чтобы узнать подробнее, для чего они нужны, напишите '--help' или '-H'\n");
                return 0;
            }

             fl_A = 1;
            arr = atoi(argv[i]);
        }
        // какой сортировкой воспользоваться
        else if(!strcmp(argv[i], "--sort") || !strcmp(argv[i], "-S")){
            i++;
            if(fl_S != 0) { // если дважды ввели один и тот же аргумент
                printf("  Вы ввели несколько одинаковых ключа! Я буду использовать последний.\n");
             }
             // если нет аргумента или он не валидный
            if((i == argc) || (atoi(argv[i]) > 2) || (atoi(argv[i]) < 1)){
                printf("  Без аргументов мне не справиться с задачей... \n Ключ '--sort' принимает в качестве аргумента числа от 1 или 2.\n Чтобы узнать подробнее, для чего они нужны, напишите '--help' или '-H'\n");
                return 0;
            }

             fl_S = 1;
            sort = atoi(argv[i]);
        }
        else if(!strcmp(argv[i], "--print") || !strcmp(argv[i], "-P")){
            i++;
            if(fl_P != 0) { // если дважды ввели один и тот же аргумент
                printf("  Вы ввели несколько одинаковых ключа! Я буду использовать последний.\n");
             }
             // если нет аргумента или он не валидный
            if((i == argc) || (atoi(argv[i]) > 1) || (atoi(argv[i]) < 0)){
                printf("  Без аргументов мне не справиться с задачей... \n Ключ '--sort' принимает в качестве аргумента числа от 1 или 2.\n Чтобы узнать подробнее, для чего они нужны, напишите '--help' или '-H'\n");
                return 0;
            }

             fl_P = 1;
            prnt = atoi(argv[i]);
        }
        else {
            printf("  Не знаю команды '%s'... \n  Но есть список известных мне ключей! Чтобы открыть его введите '--help' или просто '-H'\n", argv[i]);
            printf("  Будьте внимательны: ключ '--help' не используется в сочетании с другими ключами!!!\n");
            return 0;
        }

    }


    // пора воспользоваться введёнными данными

    // выделение памяти и проверка, выделилась ли она
    double *mas = (double*)calloc(dim, sizeof(double));

    if (!mas) {
        printf("  Не удалось выделить нужное количество памяти(");
        return 0;
    }

    //если массив должен быть отсортирован
    if (arr == 1) {
        for (i = dim - 1; i >= 0; i--) {
            mas[i] += dim - i;
        }
    }

    //если массив должен быть отсортирован в обратном порядке
    else if (arr == 2) {
        for (i = 1; i <= dim; i++) {
            mas[i] += i;
        }
    }
    // иначе, генерируем массив случайных чисел
    else {
       g_mas(mas);
    }


    // перейдём к сортировке
    if (sort == 1) {
        choosen(mas, dim);
    }

    else if (sort == 2) {
        recursia(mas, dim);
    }


   printf("\t Число сравнений элементов массива: %d\n", comp);
   printf("\t Число обменов элементов массива: %d\n", swap);

    if (prnt == 1) {
        if (dim >= 1000) {
            printf("  Массив слишком большой. При выводе он заполонит Вам весь экран. Поэтому я отказываюсь его печатать.\n");
            printf("  Если вам прям очень хочется посмотреть на отсортированный массив, передайте в ключ '--dim' аргумент меньше 1000");
            free(mas);
            return 0;
        }
        printf("  Отсортированный по невозрастанию модулей массив:\n");
        for (i = 0; i < dim; i++) {
            printf("%lf ", mas[i]);
        }
    }

    free(mas);
    return 0;

    return 0;
}

// стартовый вывод
void start(void) {
    printf("\t\t Доброго времени суток! \n   Вы находитесь в проекте Ратовой Ярославы, студента 105 группы ВМК МГУ:\n");
    printf("\t\t 'ПЛОЩАДЬ ПЛОСКОЙ ФИГУРЫ' \n ");
    printf("\n");
    printf("\t Не знаете, как пользоваться? - Не проблема!\n");
    printf("  Введите '--help' или просто '-H' и Вам высветится справка.\n");
    printf("  Будьте внимательны: ключ '--help' не используется в сочетании с другими ключами!!!\n");
    printf("\n");
    printf("\tНемного о том, что происходит:\n");
    printf("  Программа приближённо вычисляет площадь фигуры, ограниченной тремя функциями:\n");
    printf("   f1(x) = 2^x + 1,\n");
	printf("   f2(x) = x^5,\n");
	printf("   f3(x) = (1 - x) / 3.\n");
    printf("Параметры:\n\t--help -H справка;\n");
	printf("\t--first -F 1|2|3 выбор первой функции из набора f1, f2, f3;\n");
	printf("\t--second -S 1|2|3 выбор второй функции из набора f1, f2, f3;\n");
	printf("\t--left -A [A] задание левой границы отрезка (вещественное число);\n");
	printf("\t--right -B [B] задание правой границы отрекза (вещественное число);\n");
	printf("\t--epsilon -E [eps] задание точности, с которой происходят вычисления (при вычислении площади изначально считается равной 0.001, но может быть изменена);\n");
	printf("\t--vertices -V вывод абсцисс точек пересечения кривых, заданных функциями;\n");
	printf("\t--iterations -I вывод числа итераций, необходимых для вычисления корней уравнений.\n");

	printf("Примеры запуска программы:\n");
	printf("\t./main_prog -M area -- вычисление площади фигуры со стандартной точностью eps=0.001\n");
	printf("\t./main_prog -M area -E 0.01 -V -I -- вычисление площади фигуры с точностью eps=0.01, выводом абсцисс точек пересечения и кол-ва потребовавшихся итераций в цикле поиска корня\n");
	printf("\t./main_prog -M root -F 1 -S 2 -A -10.0 -B 10.0 -E 0.1 -- вычисление корня уравнения f1(x) - f2(x) = 0 на отрезке [-10, 10] с точностью eps=0.1\n");
	printf("\t./main_prog -M integral -F 3 -A 0.0 -B 20.0 -E 0.0001 -- вычисление определённого интеграла от функции f3(x) на отрезке [0, 20] с точностью eps=0.0001\n");

}

// справка
void help(void) {
    printf("\t\tВот справка:\n  1) --dim (-D) - размер массива. По умолчанию 100\n");
    printf("  2) --arr (-A) |1|2|3|4|- вид входного массива. По умолчанию 1\n");
    printf("\tВ качестве аргумента принимает число от 1 до 4:\n");
    printf("\t 1 - элементы упорядочены\n");
    printf("\t 2 - элементы упорядочены в обратном порядке\n");
    printf("\t 3 - случайный порядок элементов\n");
    printf("\t 4 - случайный порядок элементов, но не как в предыдущем\n");
    printf("  3) --sort (-S) |1|2| - вид сортировки. По умолчанию 1\n");
    printf("\tВ качестве аргумента принимает числа 1 или 2:\n");
    printf("\t 1 - сортировка выбором\n");
    printf("\t 2 - быстрая сортировка\n");
    printf("  4) --print (-P) |0|1| - выводит отсортированный массив. По умолчанию 0\n");
    printf("\tВ качестве аргумента принимает числа 0 или 1:\n");
    printf("\t 0 - не выводить\n");
    printf("\t 1 - вывести массив\n");
    printf("\n");
    printf("  Пример ввода:\n");
    printf("\t --dim 10 -A 2 - выполнит сортировку 10 элементов, упорядоченных по невозрастанию\n");
    printf("\n");
    printf("\t\t Пользуйтесь на здоровье!\n");
}
